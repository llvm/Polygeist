#!/bin/bash
# Evaluate the performance difference between Pluto and Polymer.

PLUTO_OPTIONS="--noparallel --noprevector --nounrolljam"
CLANG_NO_VECTORIZE_OPTIONS="-fno-vectorize -fno-slp-vectorize -fno-tree-vectorize"
CLANG_NO_UNROLL_OPTIONS="-fno-unroll-loops"
SKIP_EXECUTE="false"
SKIP_CODEGEN="false"
PLUTO_VARIANT=""
DELETE_WORKDIR="false"
SKIPPED_TESTS="adi"

OPT_CONFIG="1" # 1 stands for single O3, 2 for double O3

while getopts ":hdgsupvf:t:c:" opt; do 
  case "${opt}" in 
    h ) 
      echo ""
      echo "    Performance evaluator for Pluto and Polymer."
      echo ""
      echo "Usage: "
      echo "    -h                  Display this help message"
      echo "    -d                  Delete the working directory when finished"
      echo "    -s                  Skip the actual run"
      echo "    -g                  Skip the Pluto and Polymer codegen"
      echo "    -v                  Enable vectorization by Clang"
      echo "    -u                  Enable loop unroll by Clang"
      echo "    -p                  Enable parallelization"
      echo "    -f <target>         Evaluate the <target> file"
      echo "    -t <pluto var>      Specific Pluto variant (i64, 1d, etc.)"
      exit 0
      ;;
    f )
      TARGET="${OPTARG}"
      ;;
    d )
      DELETE_WORKDIR="true"
      ;;
    t )
      PLUTO_VARIANT="${OPTARG}"
      ;;
    g )
      SKIP_CODEGEN="true"
      ;;
    s )
      SKIP_EXECUTE="true"
      ;;
    p )
      PLUTO_OPTIONS=""
      ;;
    v )
      CLANG_NO_VECTORIZE_OPTIONS=""
      ;;
    u )
      CLANG_NO_UNROLL_OPTIONS=""
      ;;
    c )
      OPT_CONFIG="${OPTARG}"
      ;;
    \? )
      echo "Invalid Option: -$OPTARG" 1>&2
      exit 1
      ;;
  esac
done
shift $((OPTIND -1))

CLANG_OPTIONS="${CLANG_NO_VECTORIZE_OPTIONS} ${CLANG_NO_UNROLL_OPTIONS}"

if [ "${PLUTO_VARIANT}" = "i64" ]; then
  PLUTO_OPTIONS="${PLUTO_OPTIONS} --indvar_type 64"
fi 

TEST_CASE="$(cd "$(dirname "${TARGET}")"; pwd)/$(basename "${TARGET}")"
DIR="$(cd "$(dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd)"
TMPDIR="${DIR}/tmp"
UTILITIES_DIR="${DIR}/utilities"
PLUTO_DIR="${DIR}/../../pluto"
LLVM_DIR="${DIR}/../../llvm"
POLYMER_DIR="${DIR}/../../"

export PATH="${PATH}:${PLUTO_DIR}"
export PATH="${LLVM_DIR}/build/bin:${PATH}"
export PATH="${POLYMER_DIR}/build/bin:${PATH}"

# Compile and run the source file by Pluto.
# Args:
#    SRC_FILE           File to be compiled and run
# Outputs:
#    PLUTO_EXE_FILE     Path to the Pluto-compiled executable
#    PLUTO_RUN_TIME     Total run time of the Pluto-compiled executable
# Globals:
#    SKIP_EXECUTE       Skip the execution
#    SKIP_CODEGEN       Skip the codegen
#    UTILITIES_DIR      Where the polybench utilities placed
#    PLUTO_VARIANT      Specific Pluto variant
function run_pluto() 
{
  local SRC_FILE="$1"
  local PLUTO_SUFFIX=".pluto"
  if [ ! -z "${PLUTO_VARIANT}" ]; then
    PLUTO_SUFFIX="${PLUTO_SUFFIX}.${PLUTO_VARIANT}"
  fi

  local __RESULT_PLUTO_EXE_FILE="$2"
  local __RESULT_PLUTO_RUN_TIME="$3"
  local SRC_DIR="$(dirname "${SRC_FILE}")"
  local PLUTO_SRC_FILE="${SRC_FILE%.c}${PLUTO_SUFFIX}.c"
  local PLUTO_LLVM_IR_FILE="${PLUTO_SRC_FILE%.c}.ll"
  local PLUTO_EXE_FILE="${PLUTO_SRC_FILE%.c}.exe"
  local POLYCC_LOG="polycc_$(date "+%Y%m%d-%H%M%S").log"
  local POLYBENCH_SRC_FILE="${UTILITIES_DIR}/polybench.c"

  cd "${SRC_DIR}" >/dev/null 2>&1

  # Apply Pluto
  if [[ "${SKIP_CODEGEN}" = "false" ]]; then
    polycc "${PLUTO_OPTIONS}" "${SRC_FILE}" -o "${PLUTO_SRC_FILE}" 2>&1 >"${POLYCC_LOG}"
  fi
  if [ ! -f "${PLUTO_SRC_FILE}" ]; then
    echo "Expected Pluto output ${PLUTO_SRC_FILE} does not exist."
    exit 1
  fi

  # Compile Pluto generated code
  if [ "${OPT_CONFIG}" = "1" ]; then
    clang "${PLUTO_SRC_FILE}" -o "${PLUTO_LLVM_IR_FILE}" -S -emit-llvm -I "${UTILITIES_DIR}" -O -Xclang -disable-llvm-passes \
      -D POLYBENCH_TIME -D POLYBENCH_NO_FLUSH_CACHE -D EXTRALARGE_DATASET  
  elif [ "${OPT_CONFIG}" = "2" ]; then
    clang "${PLUTO_SRC_FILE}" -O3 ${CLANG_OPTIONS} -o "${PLUTO_LLVM_IR_FILE}" -S -emit-llvm -I "${UTILITIES_DIR}" \
      -D POLYBENCH_TIME -D POLYBENCH_NO_FLUSH_CACHE -D EXTRALARGE_DATASET  
  fi

  clang "${PLUTO_LLVM_IR_FILE}" "${POLYBENCH_SRC_FILE}" -O3 ${CLANG_OPTIONS} -o "${PLUTO_EXE_FILE}" -lm \
    -D POLYBENCH_TIME -D POLYBENCH_NO_FLUSH_CACHE -D EXTRALARGE_DATASET -save-temps

  # Run the Pluto-compiled executable
  if [ "${SKIP_EXECUTE}" = "false" ]; then
    eval $__RESULT_PLUTO_RUN_TIME="$("${PLUTO_EXE_FILE}")"
  fi
  eval $__RESULT_PLUTO_EXE_FILE="${PLUTO_EXE_FILE}"

  cd - >/dev/null 2>&1
}

# Compile and run Polymer generated MLIR code.
# Args:
#    SRC_FILE             File to be compiled and run
# Outputs:
#    POLYMER_EXE_FILE     Path to the Polymer-compiled executable
#    POLYMER_RUN_TIME     Total run time of the Polymer-compiled executable
# Globals:
#    SKIP_EXECUTE       Skip the execution
#    SKIP_CODEGEN       Skip the codegen
#    UTILITIES_DIR      Where the polybench utilities placed
function run_polymer()
{
  local SRC_FILE="$1"
  local __RESULT_POLYMER_EXE_FILE="$2"
  local __RESULT_POLYMER_RUN_TIME="$3"
  local POLYMER_SRC_FILE="${SRC_FILE%.mlir}.polymer.mlir"
  local POLYMER_LLVM_IR_FILE="${SRC_FILE%.mlir}.polymer.ll"
  local POLYMER_CLAST_FILE="${SRC_FILE%.mlir}.polymer.cloog"
  local POLYMER_EXE_FILE="${SRC_FILE%.mlir}.polymer.exe"
  local POLYBENCH_SRC_FILE="${UTILITIES_DIR}/polybench.c"

  local SRC_DIR="$(dirname "${SRC_FILE}")"

  cd "${SRC_DIR}" >/dev/null 2>&1
  if [ "${SKIP_CODEGEN}" = "false" ]; then
    # Generate Polymer optimized MLIR code.
    polymer-opt -reg2mem -extract-scop-stmt -pluto-opt="dump-clast-after-pluto=${POLYMER_CLAST_FILE}" -canonicalize \
      "${SRC_FILE}" 2>/dev/null > "${POLYMER_SRC_FILE}"
    # Compile Polymer generated MLIR code.
    mlir-opt -lower-affine -convert-scf-to-std -inline -cse -canonicalize -convert-std-to-llvm "${POLYMER_SRC_FILE}" |\
      mlir-translate -mlir-to-llvmir > "${POLYMER_LLVM_IR_FILE}"
  fi

  if [ "${OPT_CONFIG}" = "2" ]; then
    opt -S "${POLYMER_LLVM_IR_FILE}" -O3 ${CLANG_OPTIONS} -o "${PLUTO_LLVM_IR_FILE}" 
  fi

  clang "${POLYMER_LLVM_IR_FILE}" "${POLYBENCH_SRC_FILE}" -O3 ${CLANG_OPTIONS} -o "${POLYMER_EXE_FILE}" -I "${UTILITIES_DIR}" -lm \
    -D POLYBENCH_TIME -D POLYBENCH_NO_FLUSH_CACHE -D EXTRALARGE_DATASET -save-temps

  # Run the Polymer-compiled executable
  if [ "${SKIP_EXECUTE}" = "false" ]; then
    eval $__RESULT_POLYMER_RUN_TIME="$("${POLYMER_EXE_FILE}")"
  fi
  eval $__RESULT_POLYMER_EXE_FILE="${POLYMER_EXE_FILE}"

  cd - >/dev/null 2>&1
}

if [ -f "${TEST_CASE}" ]; then
  run_pluto "${TEST_CASE}" PLUTO_EXE_FILE PLUTO_RUN_TIME
  echo "Pluto run time:   ${PLUTO_RUN_TIME}" 

  run_polymer "${TEST_CASE%.c}.mlir" POLYMER_EXE_FILE POLYMER_RUN_TIME
  echo "Polymer run time: ${POLYMER_RUN_TIME}" 
elif [ -d "${TEST_CASE}" ]; then 
  # Create a working directory in the tmp directory.
  BASEDIR="$(basename "${TEST_CASE}")"
  WORKDIR="${TMPDIR}/${BASEDIR}.$(date "+%Y%m%d-%H%M%S")"
  WORKLOG="${TMPDIR}/${BASEDIR}.$(date "+%Y%m%d-%H%M%S").log"

  mkdir -p "${WORKDIR}"
  cp -r "${TEST_CASE}"/* "${WORKDIR}"

  # Check every subdirectory. 
  for d in "${WORKDIR}"/*/; do

    BASE_FILE_NAME="$(basename ${d})"
    TEST_FILE="${d}/${BASE_FILE_NAME}.c"

    PLUTO_RESULT_STR="${BASE_FILE_NAME}"
    POLYMER_RESULT_STR="${BASE_FILE_NAME}"

    if [[ ! "*${BASE_FILE_NAME}*" =~ "${SKIPPED_TESTS}" ]]; then
      echo "Running ${BASE_FILE_NAME} ..."

      for i in {1..5}; do
        run_pluto "${TEST_FILE}" PLUTO_EXE_FILE PLUTO_RUN_TIME &>/dev/null
        echo "Pluto run time:   ${PLUTO_RUN_TIME}" 
        PLUTO_RESULT_STR="${PLUTO_RESULT_STR},${PLUTO_RUN_TIME}"

        run_polymer "${TEST_FILE%.c}.mlir" POLYMER_EXE_FILE POLYMER_RUN_TIME &>/dev/null
        echo "Polymer run time: ${POLYMER_RUN_TIME}" 
        POLYMER_RESULT_STR="${POLYMER_RESULT_STR},${POLYMER_RUN_TIME}"
      done

      echo "${PLUTO_RESULT_STR}" >> "${WORKLOG}"
      echo "${POLYMER_RESULT_STR}" >> "${WORKLOG}"
    fi
  done

  if [ "${DELETE_WORKDIR}" = "true" ]; then
    rm -rf "${WORKDIR}"
  fi
fi
